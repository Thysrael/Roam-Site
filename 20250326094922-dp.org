:PROPERTIES:
:ID:       4b43a52b-cc16-489f-bde7-f0994750168b
:END:
#+title: DP

* 无后效性
时隔多年，我们又来讨论 DP 的无后效性了。

无后效性的官方定义是“如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响”，我当时还尝试解释了这个定义，“重要的是我已经是北航的学生了，不重要的是我是如何上北航的”。这个理解是没有错的，但是它没有指导 DP 算法的实践。

我现在的心得是 *“状态设计直接决定有无后效性，总能够通过设计足够复杂的状态，来使得算法具有后无效性，但是此时的状态空间就是不可遍历的了”* ，所以我们思考 DP 的过程，其本质就是在进行状态设计，让这个状态设计可以被遍历。更具体地说，我们不但需要找到一种最优子结构，而且我们还需要一个状态设计来描述这种最优子结构，如果办不到的话，那么这个问题就不能用 DP 来解决。

我们举一个例子：

在一个二维格子纸上，我们指定一个 source 和一个 target 的，我们需要计算他们之间的路径数目。

第一个小问，我们限制行走时，我们 *只能往下走或者往右走* 。第二个小问，我们限制行走时，我们 *可以随意走，但是不能走重复的点* 。我们来看一个例子：

[[file:img/clipboard-20250326T105825.png]]

在例子中，从左上角的点到黑色点，图上有蓝、黑、红三条路径，对于第一小问，蓝和黑路径都是符合要求的，而红色是不符合要求的，而对于第二小问来说，则是都符合要求的。

对于第一问，我们可以设计状态 $dp[i][j]$ 来表示从左上角第 $i$ 行第 $j$ 列的点的路径条目，然后状态转移方程为：

$$
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
$$

表示分别从上面或者左边来的点进行状态转移。但是对于第二问，如果我们还采用 $dp[i][j]$ 的状态设计，那么转移方程就是：

$$
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i + 1][j] + dp[i][j + 1]
$$

但是这种方式是错误的，因为它没有考虑重复遍历的问题，图上的路径是没有问题的，但是并不是所有的路径都没有问题，没准某条以第 $i + 1$ 行第 $j$ 列的点为终点的路径，就是刚好经过了第 $i$ 行第 $j$ 列的点。

为了记录哪些点被遍历了，我们还需要一个集合来记录他们，最简单构建集合的方式就是用一个 mask 来记录，用一个长为 16bit 的 int 来记录，其中每个 bit 都表示着一个点是/否被访问。

但是这样就会发现要遍历的空间会变得巨大：

$$
dp[i][j][v[i, j] == True] = \sum dp[i - 1][j][v[i, j] \neq True] + \sum dp[i][j - 1][v[i, j] \neq True] + \sum dp[i + 1][j][v[i, j] \neq True] + \sum dp[i][j + 1][v[i, j] \neq True]
$$
