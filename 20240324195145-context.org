:PROPERTIES:
:ID:       3efde90e-931e-458e-8a09-c448d0a2ffa1
:ROAM_ALIASES: 上下文
:END:
#+title: Context

* 种类
CPU 的运行总是需要在一个环境中，也就是上下文 context 中。

我觉得上下文概念的核心是：

#+begin_quote
CPU + Context = Function
#+end_quote

也就是说，正是因为上下文的不同，才导致了 CPU 执行的功能不同。如果要理解不同的上下文，那么应当理解不同的功能。处理器的功能如下：

- 初始化系统
- 运行用户程序
- 处理异常，大部分是在进行系统调用
- 处理中断

所以就对应有这么多种上下文。

* 每种上下文都一样吗？
这里说的一样，指的是他们的规模是一样的吗？他们的 ~sizeof~ 的结果是相同的吗？

其实并不是，在异常处理上下文中，上下文是包括产生异常的这个进程的信息的，我们需要利用这个进程的信息来完成工作，但是在中断处理中，就没有这个额外的信息。

异常是同步的，发生异常的进程和这个异常密切相关；中断是异步的，发生中断的进程只是碰巧在中断到来时在 CPU 上执行罢了。

按照这种说法，我们可以将上下文划为两类：

- *进程上下文* ：有进程信息的，无论此时在用户态还是内核态
- *中断上下文* ：没有进程信息的

* 上下文切换
正是为了切换，我们才提出了上下文的概念，上下文就是为了保证切换能够被描述而发明出来的概念。切换有如下种类：

- 进程上下文之间的切换被称为[[id:17e9d23f-ac97-46b4-ac4c-a7e54f839bf4][进程抢占]]
- 中断上下文之间的切换被称为[[id:8262a4b3-061b-410e-9acf-a70af20efb5e][中断嵌套]]
- 由进程上下文切换成中断上下文被称为中断处理
- 进程上下文一般不能切换成中断上下文

这种分类其实反映了一个现象，就是中断处理在 OS 中的优先级很高，之所以很高，我觉得和实时性有关，很多能够产生中断的设备都需要将信息实时地反馈给 CPU 处理。所以中断可以切换进程。

另一方面，中断的强实时性也影响了其他中断的强实时性，一个中断往往是[[id:ebf588e5-e1e2-4cc0-8b4d-9caf9b3b6cde][原子中断]] ，此时再有中断来，则无法及时响应。所以我们往往要求中断处理较短。

